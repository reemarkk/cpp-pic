# CPP-PIC: My Answer to the Assembly vs C Debate

## The Debate

Long long time ago in corner of dark net two users were debating which programming language is good.

1. One says Assembler allows you to control mostly everything
2. Second says C is more higher language and writing complex things using asm like TLS client is hard where in C it is good choice.

That debate ended with kick out ASM coder from that forum.

I want to add my two cents to that debate even though long time passed.

---

## The Problem: Why ASM and C Fall Short

When writing position-independent code (shellcode, kernel drivers, bootloaders, UEFI apps, embedded firmware), you face three main problems:

### 1. No .data/.rdata/.rodata Sections
Everything must be in code section (.text) - can't store string literals or floating-point constants in separate data sections.

### 2. Strings Must Be on Stack
Must build strings character by character at runtime. No way to use `"Hello"` directly.

### 3. Working with Double or Int64
32-bit systems don't have native 64-bit operations. Floating-point needs FPU or software implementation. Type conversions generate compiler constants in .rdata.

### Why Each Language Fails

**Assembly:**
- ✅ Full control, no .rdata
- ❌ Extremely hard to maintain
- ❌ Writing printf in ASM? Good luck!
- ❌ Platform-specific (x86 won't work on ARM)

**C:**
- ✅ Better for complex logic
- ❌ String literals create .rdata
- ❌ Floating-point constants create .rdata
- ❌ Limited type system

**Standard C++:**
- ✅ Great abstractions
- ❌ Generates .rdata automatically
- ❌ Breaks position-independence

---

## The Solution: CPP-PIC

**This is cpp-pic. Yes, not ASM or C - it's C++23!**

### What You Get

✅ **String literals without .rdata**
```cpp
auto msg = "Hello, World!"_embed;  // Built on stack
```

✅ **Floating-point constants without .rdata**
```cpp
auto pi = 3.14159_embed;  // Embedded as 64-bit immediate
```

✅ **64-bit integers everywhere**
```cpp
INT64 bignum = 1234567890;
UINT64 result = bignum * bignum;  // Works on 32-bit!
```

✅ **Printf-style formatting**
```cpp
Console::WriteFormatted<WCHAR>(L"Value: %d, Pi: %.5f\n"_embed, 42, 3.14159_embed);
```

✅ **12 platform combinations:** Windows/Linux/UEFI × i386/x86_64/ARMv7-A/AArch64

✅ **Modern C++23:** Templates, consteval, fold expressions, concepts, user-defined literals

---

## How It Works

### String Embedding

**Traditional C++:**
```cpp
const char* msg = "Hello";  // Goes to .rdata section
```
```asm
.section .rdata
.LC0: .string "Hello"
.section .text
    lea rax, [rip + .LC0]  ; Relocation!
```

**CPP-PIC:**
```cpp
auto msg = "Hello"_embed;  // Expands to EMBEDDED_STRING<char, 'H', 'e', 'l', 'l', 'o'>
```
```asm
movb $0x48, (%rax)      ; 'H' as immediate
movb $0x65, 1(%rax)     ; 'e'
movb $0x6C, 2(%rax)     ; 'l'
movb $0x6C, 3(%rax)     ; 'l'
movb $0x6F, 4(%rax)     ; 'o'
movb $0x00, 5(%rax)     ; '\0'
```

Template creates character pack at compile-time, fold expression unpacks at runtime. Each character becomes immediate value in code.

### Floating-Point Embedding

**Traditional:**
```cpp
double pi = 3.14159;  // .rdata
```
```asm
.section .rdata
.LC0: .quad 0x400921f9f01b866e
.section .text
    movsd xmm0, [rip + .LC0]
```

**CPP-PIC:**
```cpp
auto pi = 3.14159_embed;  // consteval converts to bits
```
```asm
movabsq $0x400921f9f01b866e, %rax  ; Immediate!
```

Uses `__builtin_bit_cast` at compile-time to convert double to IEEE-754 bits, then embeds as 64-bit immediate.

### 64-bit Software Implementation

```cpp
class UINT64 {
    UINT32 low, high;  // Split into 32-bit words
public:
    UINT64 operator+(const UINT64&) const;  // Software arithmetic
    UINT64 operator*(const UINT64&) const;
    // All operations in pure software
};
```

Works even on 32-bit systems!

### Type Conversions

Pure bit manipulation - no FPU, no .rdata:

```cpp
INT64 operator(INT64)(const DOUBLE& d) {
    // Extract sign, exponent, mantissa via bit shifts
    // Reconstruct integer using pure arithmetic
}
```

### Complete Example

```cpp
#include "platform.h"
#include "console.h"

ENTRYPOINT INT32 _start(VOID) {
    ENVIRONMENT_DATA envData;
    Initialize(&envData);

    Console::Write<WCHAR>(L"CPP-PIC Runtime v2.0\n"_embed);

    DOUBLE pi = 3.14159265358979_embed;
    Console::WriteFormatted<WCHAR>(L"Pi = %.15f\n"_embed, pi);

    INT64 bignum = INT64(9223372036854775807);
    Console::WriteFormatted<WCHAR>(L"Big number = %ld\n"_embed, bignum);

    ExitProcess(0);
}
```

ZERO .rdata dependencies. Fully position-independent. Modern C++23.

---

## Platform Support

| Platform | i386 | x86_64 | ARMv7-A | AArch64 |
|----------|------|--------|---------|---------|
| **Windows** | ✅ | ✅ | ✅ | ✅ |
| **Linux** | ✅ | ✅ | ✅ | ✅ |
| **UEFI** | ✅ | ✅ | ❌ | ✅ |

**12 fully supported combinations!**

**Windows:** PEB walking, NtDll syscalls, no imports (Windows 2000-11)
**Linux:** Direct syscalls (int 0x80/syscall/svc), no libc
**UEFI:** Boot Services, System Table, pre-boot environment

---

## Building

**This project is designed to use with VSCode!**

### VSCode (Recommended)

Open in VSCode and get:
- `Ctrl+Shift+B` - Build all configurations
- `F5` - Run/Debug
- 20+ pre-configured build tasks
- One-click UEFI testing with QEMU
- IntelliSense for C++23

### Manual CMake

```bash
cmake -B build -G Ninja \
  -DCMAKE_TOOLCHAIN_FILE=cmake/toolchain-clang.cmake \
  -DARCHITECTURE=x86_64 -DPLATFORM=windows
cmake --build build
```

**But seriously, use VSCode - it's so much easier!**

---

## Use Cases

### 1. Kernel Development
Modern C++23 in Windows/Linux drivers. No paged memory needed, works in interrupt context.

### 2. UEFI Applications
Sophisticated pre-boot tools using C++23 features.

### 3. Embedded Firmware
C++23 on microcontrollers executing from ROM.

### 4. Security Research
Position-independent payloads for authorized testing.

### 5. Cross-Platform Tools
Single codebase for 12 platform combinations.

---

## Performance Trade-offs

### Binary Size
| Section | Traditional | CPP-PIC | Change |
|---------|-------------|---------|--------|
| `.text` | 8,192 bytes | 10,752 bytes | +31% |
| `.rdata` | 2,048 bytes | 32 bytes | -98% |
| **Total** | **10,240 bytes** | **10,784 bytes** | **+5%** |

### Runtime
- String construction: ~10 cycles (one-time cost)
- Float literals: **2× faster** (immediate vs memory)
- Arithmetic: Zero overhead (same instructions)
- Type conversions: 4× slower (rarely critical)

### Compilation
40-80% slower due to template instantiation. Acceptable for <100K LOC.

### When to Use
✅ Position-independent code required
✅ Kernel/UEFI/embedded environments
✅ ROM execution

❌ Performance-critical string processing
❌ Thousands of unique string literals
❌ Real-time systems

---

## Conclusion: C++ Gives You BOTH

### Who Won the Debate?

- Assembly coder: "Assembly gives you control"
- C coder: "C gives you productivity"

**My answer: C++ gives you BOTH.**

### What CPP-PIC Proves

**Assembly-level control:**
- No .rdata, no relocations, no dependencies
- Full memory layout control
- Position-independent

**C++ productivity:**
- Templates, type safety, C++23 features
- Printf formatting, operator overloading
- RAII, compile-time guarantees

**Better than both:**
- 12 platforms from single codebase
- Zero-overhead abstractions

### The Real Lesson

The debate was wrong. It's not "Assembly vs C vs C++".

**The question is: How far can we push modern languages into constrained environments?**

CPP-PIC proves that with understanding of:
- Compiler internals
- Binary formats (PE/ELF)
- Platform syscalls
- C++23 metaprogramming

...we can bring modern C++ everywhere.

### You Don't Have to Choose Anymore

Want everything? ✅ Got it.
- Printf, floats, strings, templates
- Position-independence, no .rdata
- Cross-platform

**Language choice should never be limited by compiler behavior.**

### Final Thoughts

That debate from long ago where they kicked out the ASM coder?

**Both were right. And both were wrong.**

Modern C++, used correctly, gives **both control and abstraction**.

CPP-PIC is working code:
- 15,000 lines of C++23
- 12 platform/architecture combinations
- Comprehensive test suite

It proves "impossible" is often "not yet implemented."

Next time someone says:
- "You can't use C++ in kernel mode"
- "You can't use C++ without .rdata"
- "You need assembly for position-independent code"

**Show them CPP-PIC.**

**The boundaries we accept are often just assumptions waiting to be challenged.**

---

## Technical Specs

**CPP-PIC** (Position-Independent C++23 Runtime)
- **Languages:** C++23
- **Compiler:** LLVM/Clang 20+
- **Build:** CMake 3.20+ with Ninja
- **Size:** ~15,000 LOC, 34 headers, 21 source files
- **Platforms:** Windows, Linux, UEFI
- **Architectures:** i386, x86_64, ARMv7-A, AArch64
- **Configurations:** 24 (debug/release × 3 × 4)
- **License:** Proprietary (Educational & Authorized Security Research)

---

**Author's Note:**

Years of research into compilers, binary formats, linkers, and platform programming. This proves modern C++ belongs everywhere - even the most constrained environments.

The original debate ended with someone kicked out. This project is my answer - not words, but working code.

**The boundaries are only in our minds.**
